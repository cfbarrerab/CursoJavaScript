# JavaScript 1

Date Created: 27 de julio de 2023 15:33
Status: Done üôå

# Ejecutar JavaScript

Se ejecuta por medio de VSC. Se debe crear un archivo index.html y en las l√≠neas de c√≥digo, poner <script>. Esto le da a entender al editor que estamos trabajando en Java

![Untitled](img/Untitled.png)

Consola: Es donde se ve el resultado del c√≥digo JS

Para verlo, abrimo el archivo index.html y se abrir√° en Chrome. Ahora se usa Ctrl+shift+j para ver la consola

# Comentarios

Son textos que se incluyen pero que no hacen parte del c√≥digo como tal. Son usados como gu√≠a

Se hacen con dos

//

![Untitled](img/Untitled%201.png)

![Untitled](img/Untitled%202.png)

# Variables

Tipos de datos: Undefined (no existe valor asignado), null (nulo), boolean (booleano), string (cadena de caracteres), symbol, number (numero) & object

Variable: Crea un espacio en el dispositivo y guarda un valor en ese lugar de memoria

![Untitled](img/Untitled%203.png)

# Operador de Asignaci√≥n

Si se definen variables pero no su valor, en la consola se ver√° reflejado como valor indefinido

![Untitled](img/Untitled%204.png)

![Untitled](img/Untitled%205.png)

Podemos darle un valor a la variable despues de creada

![Untitled](img/Untitled%206.png)

# Asignar el valor de una variable a otra variable

![Untitled](img/Untitled%207.png)

![Untitled](img/Untitled%208.png)

# Variables no Inicializadas

Son aquellas variables a las que no se les ha asignado un valor

![Untitled](img/Untitled%209.png)

# May√∫sculas y Min√∫culas

En JS es importante que las variables sean escritas como se declararon, respetando may√∫sculas y min√∫sculas

![Untitled](img/Untitled%2010.png)

# Operaciones Aritm√©ticas

![Untitled](img/Untitled%2011.png)

![Untitled](img/Untitled%2012.png)

![Untitled](img/Untitled%2013.png)

![Untitled](img/Untitled%2014.png)

# N√∫meros Decimales

![Untitled](img/Untitled%2015.png)

Aplican la misma manera de las operaciones artim√©ticas

# Residuo de una divisi√≥n.

Esta operaci√≥n da el valor del residuo de una divisi√≥n, es decir si divido 17/3 nos da 5,6. Pero el residuo es aquello que no se puede dividir de manera entera es decir que dar√≠a 5 y residuo 2. Se hace con%

![Untitled](img/Untitled%2016.png)

# Incrementar el valor de una variable

![Untitled](img/Untitled%2017.png)

![Untitled](img/Untitled%2018.png)

![Untitled](img/Untitled%2019.png)

![Untitled](img/Untitled%2020.png)

# Reducci√≥n del valor de una variable

![Untitled](img/Untitled%2021.png)

![Untitled](img/Untitled%2022.png)

# Asignaci√≥n de Suma

Cuando se desea sumar una variable a un numero, se puede hacer de forma abreviada

![Untitled](img/Untitled%2023.png)

Otro Ejemplo

![Untitled](img/Untitled%2024.png)

# Asignaci√≥n de Resta

![Untitled](img/Untitled%2025.png)

# Asignaci√≥n de la Multiplicaci√≥n

![Untitled](img/Untitled%2026.png)

# Asignaci√≥n de Divisi√≥n

![Untitled](img/Untitled%2027.png)

# Variable con Cadenas de Caracteres

![Untitled](img/Untitled%2028.png)

# Escapar Comillas en Cadenas de Caracteres

Si se desea declarar una variable de caracteres que incluyan comillas, debe hacerse de la siguiente manera \‚Äùtexto‚Äù

![Untitled](img/Untitled%2029.png)

# Escape de Caracteres con Comillas Simples

![Untitled](img/Untitled%2030.png)

![Untitled](img/Untitled%2031.png)

Se puede hacer tambi√©n intercalando comillas simples y comillas dobles como se muestra en los ejemplo

# Secuencias de Escape

Son combinaciones de caracteres que no se representan a s√≠ mismos como caracteres como tal

![Untitled](img/Untitled%2032.png)

# Concatenar Cadenas de Caracteres

![Untitled](img/Untitled%2033.png)

# Construir Cadenas con Variables

![Untitled](img/Untitled%2034.png)

# Agregar Variables a Cadenas de Caracteres

![Untitled](img/Untitled%2035.png)

# Longitud de una cadena de caracteres

Para conocer la cantidad de caracteres de una variable, al momento de imprimir se agrega .lenght, es decir console.log(variable.length)

![Untitled](img/Untitled%2036.png)

# Notaci√≥n de Corchetes: Primer Caracter

Nos permite acceder a un caracter especial de una cadena

![Untitled](img/Untitled%2037.png)

# Inmutabilidad de Cadena de Caracteres

Una vez definida una cadena de caracteres, no es posible cambiar alg√∫n elemento de ella.

![Untitled](img/Untitled%2038.png)

# Notaci√≥n de Corchetes: En√©simo Caracter

![Untitled](img/Untitled%2039.png)

![Untitled](img/Untitled%2040.png)

# Notaci√≥n de Corchetes: √öltimo Caracter

![Untitled](img/Untitled%2041.png)

![Untitled](img/Untitled%2042.png)

# Notaci√≥n de Corchetes: De Derecha a Izquierda

![Untitled](img/Untitled%2043.png)

y As√≠ sucesivamente

# Palabras en Blanco

Vamos a hacer que un texto se imprima en la consola declarando varibales de las palabras 

![Untitled](img/Untitled%2044.png)

# Arreglos (Arrays)

Son estructuras que permiten almacenar m√∫ltiples valores  en una misma estructura. Son como vectores.

![Untitled](img/Untitled%2045.png)

# Arreglos Anidados

Se pueden crear arreglos en los que los elementos del mismo, sean arreglos. A esto se le llaman arreglos anidados

![Untitled](img/Untitled%2046.png)

# Identificaci√≥n de un elemento de un arreglo

Se puede ubicar un elemento de un arreglo mendiante su posici√≥n

![Untitled](img/Untitled%2047.png)

# 

# Modificar los datos de un arreglo

Se pueden hacer modificaciones a los datos de un arreglo mediante la declaraci√≥n de su valor

![Untitled](img/Untitled%2048.png)

# Acceder a Arreglos Multidimensionales

Se hace mediante definicions de subindices

![Untitled](img/Untitled%2049.png)

# .push()

Este m√©todo agrega a un arreglo un valor al final de este

![Untitled](img/Untitled%2050.png)

# .pop()

Este m√©todo elimina el √∫ltimo  elemento del arreglo, pero adicional nos permite guardarlo en una nueva variable

![Untitled](img/Untitled%2051.png)

# .shift()

Elimina el primer elemento de un arreglo

![Untitled](img/Untitled%2052.png)

# .unshift()

Agrega un elemento al principio de un arreglo. Dentro del par√©ntesis se define el valor que debe tomar ese elemento que vamos a agregar

![Untitled](img/Untitled%2053.png)

# Lista de Compras

Se pueden imprimier mensajes en la consola usandop las ubicaiones de los arreglos

![Untitled](img/Untitled%2054.png)

# Funciones

Se pueden escribir c√≥digo que se puede reutilizar

![Untitled](img/Untitled%2055.png)

![Untitled](img/Untitled%2056.png)

# Argumentos

Las variables de la funci√≥n se dfinen como par√°metros

![Untitled](img/Untitled%2057.png)

para este caso, los par√°metros son a y  b

dentro de esa funci√≥n SUMAR se define que har√° esta funci√≥n

![Untitled](img/Untitled%2058.png)

Para este caso, har√° la suma de a+b y muestra en la consola la suma de estos

Ahora, con la funci√≥n definida, podemos llamarla con los valores que queramos darle a a y b

![Untitled](img/Untitled%2059.png)

Y as√≠ se muestra en la consola

![Untitled](img/Untitled%2060.png)

Los argumentos, son los VALORES QUE SE LE ASIGNAN A LOS PAR√ÅMETROS. Es decir, un argumento es un par√°metro con valor

Los par√°metros tambi√©n pueden ser definidos mediante variables de la siguiente manera

![Untitled](img/Untitled%2061.png)

# √Åmbito Globales

Es una variable que se puede usar en cualquier parte del programa, ya que est√° definida en el programa principal (no dentro de una funci√≥n)

# √Åmbito Local

Son variables definidas dentro de una funci√≥n, y solo se pueden usar dentro de esa funci√≥n

# Diferencias entre Global y Local

Si tengo dos variables con el mismo nombre, una local y otra global estas tienen diferentes jerarqu√≠as seg√∫n en donde se usen. Si se usan dentro de una funci√≥n, va a tener mayor jerarqu√≠a la variablo local. Si se hace fuera de la funci√≥n, tendr√° jerarqu√≠a la global (ya que las locales no pueden usarse fuera de la funci√≥n)

![Untitled](img/Untitled%2062.png)

[https://www.notion.so](https://www.notion.so)

# Retornar un Valor

Tenemos la funcion sumar, dentro de la funcion no siempre es necesario imprimir en la consola el resultado. Podemos calcularlo y guardar el valor sin necesidad de imprimir. Para es usamos la palabra reservada return. Asi queda el valor guardado y posteriormente podemos usarlo bien sea para imprimirlo, o para otros calculos

![Untitled](img/Untitled%2063.png)

![Untitled](img/Untitled%2064.png)

# Undefined

Si se define la funci√≥n sumar y dentro de la funci√≥n no retornamos la suma, el valor mostrado deber√° ser UNDEFINED. Es decir, siempre debemos retornar el valor

![Untitled](img/Untitled%2065.png)

# Asignar un valor retornado

Se puede asignar una variable al retorno de una funci√≥n. Se define la funci√≥n y su variable, dentro de la funci√≥n se define que es lo que vamos a retoirnar. En este caso es un mensaje. Despues de esto, fuera de la funcion definimos una valiable que ser√° igual a la funcion creada definida en la una variable especifica, ene ste casi ‚ÄúJavaScript‚Äù

![Untitled](img/Untitled%2066.png)

![Untitled](img/Untitled%2067.png)

# Permanece en L√≠nea (queue)

En inform√°tica, una cola o queue, es una estructura de datos abstracta en la cual los elemntos se mantienen en orden. Los nuevos elementos se pueden a√±adir al final de la cola y los elementos previos se retiran del principio de la cola

![Untitled](img/Untitled%2068.png)

![Untitled](img/Untitled%2069.png)

# Valores Booleanos

Son valores que pueden tomar valores de verdadero o falso. True or False. Deben escribirse en minuscula siempre (true & false).

# Operador de Igualdad ==

Es un opoerador que compara la igualdad de dos t√©rminos. Su resultado ser√° un opoerador booleano-

![Untitled](img/Untitled%2070.png)

![Untitled](img/Untitled%2071.png)

NO DEBERIAN USARSE PARA COMPARAR ARREGLOS

# Operador de Igualdad Estricta ===

Nos permite comparar si los datos son iguales y son del mismo tipo

![Untitled](img/Untitled%2072.png)

# Pr√°ctica de como comparar valores

![Untitled](img/Untitled%2073.png)

![Untitled](img/Untitled%2074.png)

# Operadores de Desigualdad ! =

Es un operador que compara la igualdad de dos valores. Su respuesta ser√° true si son distintos y false si son iguales. Es lo opuesto a los operadores de igualdad

![Untitled](img/Untitled%2075.png)

TAMPOCO DEBE USARSE PARA COMPARAR ARREGLOS

# Operador de Desigualdad Estricta ! = =

Funciona igual que el operadod de igual estricta, compara el valor y el tipo de datos. Si son iguales retornar√° false, si son diferentes retornara true

![Untitled](img/Untitled%2076.png)

# Operador Mayor Que

Compara el valor absoluto de un valor con respecto a otro. Si se da la condici√≥n ser√° true, si no false.

Para cadenas de caracteres, se dar√° por orden alfab√©tico donde a es el menor valor y z el mayor

![Untitled](img/Untitled%2077.png)

Tambi√©n ser√° usado en variables

![Untitled](img/Untitled%2078.png)

# Operador Mayor o Igual que ‚â•

Adiciona la condici√≥n de mayor√≠a e igualdad

# Operador Menor que < y menor o igual que ‚â§

Funcionan de manera similar que los dos operadores anteriores

![Untitled](img/Untitled%2079.png)

![Untitled](img/Untitled%2080.png)

# Operador L√≥gico AND &&

Nos permiten combinar expresiones para elaborar condiciones mas elaboradas

Los operadores l√≥gicos tiene tablas de verdad que determinan sus valores de salida

![Untitled](img/Untitled%2081.png)

![Untitled](img/Untitled%2082.png)

# Operador L√≥gico OR ||

![Untitled](img/Untitled%2083.png)

![Untitled](img/Untitled%2084.png)

![Untitled](img/Untitled%2085.png)

# Operador L√≥gico NOT !

![Untitled](img/Untitled%2086.png)

Se usa para negar un valor de salida

![Untitled](img/Untitled%2087.png)

![Untitled](img/Untitled%2088.png)

# Sentencias Condicionales IF

Nos permiten elegir si un bloque de c√≥digo se ejecuta o no

![Untitled](img/Untitled%2089.png)

![Untitled](img/Untitled%2090.png)

# Cl√°usula ELSE

![Untitled](img/Untitled%2091.png)

![Untitled](img/Untitled%2092.png)

![Untitled](img/Untitled%2093.png)

# Cl√°usula ELSE IF

Es para anidar IF y ELSE conjuntamente

![Untitled](img/Untitled%2094.png)

![Untitled](img/Untitled%2095.png)

# Encadenar if‚Ä¶.else

Ejercicio Pr√°ctico

![Untitled](img/Untitled%2096.png)

# C√≥digo de Golf

Ejercicio Pr√°ctico

![Untitled](img/Untitled%2097.png)

![Untitled](img/Untitled%2098.png)

![Untitled](img/Untitled%2099.png)

# Sentencias Switch

La declaraci√≥n o sentencia Switch eval√∫a una expresi√≥n, comparando el valor de esa expresi√≥n con una instancia CASE y ejecuta declaraciones asociadas a ese CASE, as√≠ como las declaraciones en los CASE que siguen

![Untitled](img/Untitled%20100.png)

![Untitled](img/Untitled%20101.png)

# Switch: Opci√≥n predeterminada

Esta opci√≥n se ejecutar√° si ninguno de los valores es el es valor de la variable o de la expresi√≥n. Se hace con DEFAULT

![Untitled](img/Untitled%20102.png)

![Untitled](img/Untitled%20103.png)

# Switch: M√∫ltiples Casos

Se puede ejecutar un c√≥digo especifico para varios valores.

![Untitled](img/Untitled%20104.png)

![Untitled](img/Untitled%20105.png)

# If‚Ä¶Else por Switch

Vamos a hacer un c√≥giso donde se obtengan los mismos resultados mediante IF-ELSE y con SWITCH

![Untitled](img/Untitled%20106.png)

![Untitled](img/Untitled%20107.png)

Ahora con SWITCH

![Untitled](img/Untitled%20108.png)

![Untitled](img/Untitled%20109.png)

# Retornar Valores Booleanos

Hay maneras mas resumidas de retornar valores booleanos. La manera como hemos visto hasta ahora con condicionales es:

![Untitled](img/Untitled%20110.png)

![Untitled](img/Untitled%20111.png)

Pero podemos retornar el valor directamente de la comparaci√≥n

![Untitled](img/Untitled%20112.png)

![Untitled](img/Untitled%20113.png)

# Patr√≥n de Retorno Anticipado

Cuando se retorna un valor de una funci√≥n, esta se detiene inmediatamente.

![Untitled](img/Untitled%20114.png)

Para este caso, la l√≠nea 4 no se ejecutar√° pues est√° despu√©s de la l√≠nea 3 que ejectuta un retorno

![Untitled](img/Untitled%20115.png)

Para este caso, si el n√∫mero es mayor que cero el programa calcular√° su ra√≠z cuadrada. Si el n√∫mero es menor que cero, el valor retornado ser√° UNDEFINED. El patr√≥n de retorno anticipado nos sirve para descartar de entrada aquellos valores que no son aplicables a nuestro c√≥digo, como es el caso de los n√∫meros negativos para el ejemplo. 

# Proyecto Conteo de Cartas

Descripci√≥n: En el juego de casino de BlackJack el jugador puede sacarle ventaja a la casa llevando un registro del n√∫mero relativo de cartas altas y bajas que quedan en la baraja. A esto le llaman CONTEO DE CARTAS. Tener m√°s cartas altas en la baraja es una ventaja para el jugador. Se le asigna un valor a cada carta de acuerdo a la siguiente tabla. Si el conteo es positivo, el jugador deber√≠a apostar alto, si el conteo es negativo o cero, el jugador deber√≠a apostar bajo.

![Untitled](img/Untitled%20116.png)

Nuestra meta es desarrollar una funci√≥n para contar cartas.

La funci√≥n debe tomar un par√°metro CARTA que puede ser un n√∫mero o una cadena de caracteres y luego aumentar o reducir el valor de la variable global CONTEO de acuerdo al valor de la carta.

La funci√≥n debe retornar una cadena de caracteres con el conteo actual y las cadenas: "Apostar" (si el conteo es positivo) o "Esperar" si el conteo es cero o negativo.

El conteo actual y la decisi√≥n del jugador (Apostar o Esperar) deben estar separados por un espacio

SOLUCI√ìN

![Untitled](img/Untitled%20117.png)

![Untitled](img/Untitled%20118.png)

![Untitled](img/Untitled%20119.png)

# Crear Objetos

Nos permiten guardar una secuencia o un conjunto de propiedades que est√°n relacionadas con sus correspondientes valores. Se definene en JS de la siguiente manera

![Untitled](img/Untitled%20120.png)

# Acceder a Propiedades: Notaci√≥n de Punto

Para acceder al valor de alguna propiedad de un objeto, se hace mediante la notaci√≥n de punto. De la siguiente manera

![Untitled](img/Untitled%20121.png)

# Acceder a Propiedades: Notaci√≥n de corchetes

Tambi√©n se pueden acceder a las distintas propiedades con esta notaci√≥n que es equivalente

![Untitled](img/Untitled%20122.png)

# Acceder a propiedades: Variables

Podemos definir una variable que sea equivalente a alguna propiedad del objeto. Y posterior, usar la notaci√≥n de corchetes para llamarlo. Como se muestra a continuaci√≥n. Esto solo puede hacerse con esta notaci√≥n, con la notaci√≥n de punto no es posible

![Untitled](img/Untitled%20123.png)

# Actualizar Propiedades

Definimos un objeto llamada MOCHILA con las propiedades mostradas. La propiedad CONTENIDO tiene m√°s de un elemento, y lo escribimos mediante un arreglo como se muestra a continuaci√≥n. Una 

![Untitled](img/Untitled%20124.png)

Una vez definida las propiedades, accedemos a la propiedad del color (l√≠nea 7) y podemos cambiarla como se muestra en la l√≠nea 8. En la l√≠nea 9 se muestra que la propiedad ya qued√≥ actualizada.

Para a√±adir elementos a la propiedad que se defina como un arreglo, para este caso CONTENIDO, usamos el m√©todo .PUSH como se muestra a continuaci√≥n

![Untitled](img/Untitled%20125.png)

O sencillamente definimos nuevamente el contenido de la propiedad con lo que se requeira

![Untitled](img/Untitled%20126.png)

# Agregar Propiedades

Para agregar una propiedad a un objeto, se puede hacer de la siguiente manera con notaci√≥n de punto y notaci√≥n de corchetes

![Untitled](img/Untitled%20127.png)

![Untitled](img/Untitled%20128.png)

# Eliminar Propiedades

Para eliminar alguna propiedad podemos hacerlo de la siguiente manera

![Untitled](img/Untitled%20129.png)

# Objetos para B√∫squedas

Por medio de OBjetos, podemos simplificar c√≥digos realizados por medio de SWITCH. Un ejemplo claro es el siguiente c√≥digo

![Untitled](img/Untitled%20130.png)

![Untitled](img/Untitled%20131.png)

![Untitled](img/Untitled%20132.png)

Ahora si lo definimos como un objeto

![Untitled](img/Untitled%20133.png)

![Untitled](img/Untitled%20134.png)

# Verificar Propiedades

Se define un objeto con sus propiedades y se valida si existe con hasOwnProperty(). El retorno ser√° booleano

![Untitled](img/Untitled%20135.png)

![Untitled](img/Untitled%20136.png)

Desarrollemos una funci√≥n que determine si un objeto tiene una propiedad

![Untitled](img/Untitled%20137.png)

![Untitled](img/Untitled%20138.png)

# Objetos Complejos

Los objetos puede definirse mediante arreglos anidados de manera compleja como se muestra a continuaci√≥n

![Untitled](img/Untitled%20139.png)

Veamos como podemos acceder a alguna de sus propiedades

![Untitled](img/Untitled%20140.png)

![Untitled](img/Untitled%20141.png)

![Untitled](img/Untitled%20142.png)

![Untitled](img/Untitled%20143.png)

# Objetos Anidados

Tambi√©n se pueden definir Objetos dentro de otros Objetos, de manera similar a a los arreglos anidados. Para acceder a alguna propiedad, podemos usar la notaci√≥n que se muestra a continuaci√≥n

![Untitled](img/Untitled%20144.png)

![Untitled](img/Untitled%20145.png)

# Arreglos Anidados

Cuando un objeto esta definido en arreglo, como en el siguiente ejemplo, se debe usar notaci√≥n de punto para acceder a alguno de sus elementos. Como se muestra a a continuaci√≥n

![Untitled](img/Untitled%20146.png)

![Untitled](img/Untitled%20147.png)

![Untitled](img/Untitled%20148.png)

# Proyecto: Colecci√≥n de Discos

Tenemos un objeto que representa parte de una colecci√≥n de √°lbumes musicales. Cada √°lbum tiene un √∫nico ID asociado a otras propiedades.

No todos los √°lbumes tienen la informaci√≥n completa

![Untitled](img/Untitled%20149.png)

# Ciclo While

Se usan cuando no se tiene un n√∫mero espec√≠fico de iteraciones, pero si se conoce lo que tiene que ser cierto para detener el proceso.

Dentro del par√©ntesis de while, ir√° la condicion del ciclo

![Untitled](img/Untitled%20150.png)

![Untitled](img/Untitled%20151.png)

Otro ejemplo

![Untitled](img/Untitled%20152.png)

![Untitled](img/Untitled%20153.png)

# Ciclo For

Lo usamos cuando sabemos cuantas iteraciones necesitamos. Dentro del par+entesis del for, ira el valor inicial; la condici√≥n final; y como queremos que se actualice la variable

![Untitled](img/Untitled%20154.png)

![Untitled](img/Untitled%20155.png)

# Ciclos For: N√∫meros Impares

Vamos a crear un arreglo con los n√∫meros impares entre 0 y 19, incluyendolo

![Untitled](img/Untitled%20156.png)

![Untitled](img/Untitled%20157.png)

Otro Ejemplo. Hagamos un arreglo que contenga todos los n√∫mero pares desde 2 hasta 26, incluyendolo

![Untitled](img/Untitled%20158.png)

![Untitled](img/Untitled%20159.png)

# Ciclos For: Contar hacia atr√°s

Hagamos un contador desde 20 hasta 11 con el ciclo for, de uno en uno

![Untitled](img/Untitled%20160.png)

![Untitled](img/Untitled%20161.png)

El mismo ejemplo con arreglo

![Untitled](img/Untitled%20162.png)

![Untitled](img/Untitled%20163.png)

# Iterar Sobre un Arreglo con ciclo For

Vamos  a crear un programa que sume los elementos de un arreglo

![Untitled](img/Untitled%20164.png)

![Untitled](img/Untitled%20165.png)

Otro Ejemplo con cadenas de caracteres, vamos a convertir las cadenas de caracteres a may√∫culas con toUpperCase

![Untitled](img/Untitled%20166.png)

![Untitled](img/Untitled%20167.png)

Otro Ejemplo, hagamos un programa que cuente los n√∫meros pares de un arreglo

![Untitled](img/Untitled%20168.png)

![Untitled](img/Untitled%20169.png)

# Ciclos For Anidados

Vamos usas ciclos for anidados para mostrar elementos de arreglos anidados

![Untitled](img/Untitled%20170.png)

![Untitled](img/Untitled%20171.png)

# Ciclos Do While

Es un ciclo muy similar a While, la diferencia es que se va a ejecutar m√≠nimo una vez el c√≥digo as√≠ no se cumpla la condici√≥n. Eso es √∫til cuando hay que pedir que un usuario ingrese un valor y as√≠ podemos compararlo.

Para este c√≥digo, x = 5. El ciclo dice que independiente de el valor de x, al  menos una vez se ejecutar√° la impresi√≥n. 

![Untitled](img/Untitled%20172.png)

Como el condicional del ciclo es que x sea menor que 10, y x lo es, se seguir√° ejecutando el c√≥digo. Entonces este imprimir√° en consola los n√∫mero del 5 al 9.

![Untitled](img/Untitled%20173.png)

Ahora si x =15, no cumple con el condicional. Sin embargo imprimir√° una vez el valor de x por que as√≠ es la naturaleza del ciclo

![Untitled](img/Untitled%20174.png)

![Untitled](img/Untitled%20175.png)

# Proyecto: Buscar Contactos

Vamos a hacer un proyecto con todo lo aprendido que nos permita buscar un contacto en una lista de contacto

![Untitled](img/Untitled%20176.png)

![Untitled](img/Untitled%20177.png)

![Untitled](img/Untitled%20178.png)

# N√∫meros aleatorio entre 0 y 1

Para poder generar n√∫meros aleatorios entre [0 y 1), podemos usar la siguiente funci√≥n matem√°tica

![Untitled](img/Untitled%20179.png)

![Untitled](img/Untitled%20180.png)

![Untitled](img/Untitled%20181.png)

![Untitled](img/Untitled%20182.png)

# N√∫meros Aleatorios Enteros

Vamos a combinar dos m√©todos establecidos en JS

Usaremos la funci√≥n floor que retorna el valor entero menor o igual de un n√∫mero. A este lo vamos a multiplicar por la funci√≥n random y as√≠ obtendremos n√∫mero enteros aleatorios entre un rango

![Untitled](img/Untitled%20183.png)

![Untitled](img/Untitled%20184.png)

![Untitled](img/Untitled%20185.png)

![Untitled](img/Untitled%20186.png)

Y as√≠ podemos crear una funci√≥n predeterminada que podremos usar posteriormente luego

![Untitled](img/Untitled%20187.png)

Ahora, si queremos generar un n√∫mero definido de n√∫meros aleatorios, podemos hacerlo mediante un ciclo de la siguiente manera

![Untitled](img/Untitled%20188.png)

![Untitled](img/Untitled%20189.png)

![Untitled](img/Untitled%20190.png)

# N√∫meros Aleatorios en un Rango

Si ahora queremos que el rango no empiece siempre desde cero, podemos establecer una operaci√≥n matem√°tica con la funci√≥n declarada anteriormente

![Untitled](img/Untitled%20191.png)

![Untitled](img/Untitled%20192.png)

![Untitled](img/Untitled%20193.png)

# Funci√≥n praseInt()

Esta funci√≥n convierte una cadena de caracteres a un entero.  Para el caso de decimales, elimina la parte decimal. 

![Untitled](img/Untitled%20194.png)

A continuaci√≥n veremos un ejemplo de su aplicaci√≥n

![Untitled](img/Untitled%20195.png)

# Funci√≥n parseInt() con una Base

Esta funci√≥n tambi√©n nos permite pasar un n√∫mero determinado a un sistema num√©rico en otra base. En este ejmpo, vamos a poner el n√∫mero 110111 y definimos que est√° en base 2. El retorno ser√° su equivalencia en base 10

![Untitled](img/Untitled%20196.png)

Ahora otro ejemplo en sistema hexadecimal

![Untitled](img/Untitled%20197.png)

# Operador Condicional Ternario

Este operador nos permite compactar un condicional en una sola l√≠nea

Para mostrarlo vamos a comparar un condicional sencillo 

![Untitled](img/Untitled%20198.png)

Esto es equivalente a 

![Untitled](img/Untitled%20199.png)

Esto lo podemos interpretar as√≠: evalue si x < y. Si esta condicion es verdadera retorne x, si no retorne y

Tambi√©n podemos usarlo para operar matem√°ticamente as√≠

![Untitled](img/Untitled%20200.png)

# M√∫ltiples operadores condicionales

Vamos a hacer una funci√≥n que contenga varios condicionales y vamos a hacerlo con condicionales ternarios para comparar.

![Untitled](img/Untitled%20201.png)

![Untitled](img/Untitled%20202.png)

# var vs let

Cuando se declara una variable con var, se puede hacer dos o m√°s veces. 

Cuando se usa con let, no es posible declararla m√°s de una vez

![Untitled](img/Untitled%20203.png)

![Untitled](img/Untitled%20204.png)

# √Åmbito de var vs. let

Cuando se usa var, la varible puede ser global o local. Let es m√°s estricto en eso, por ejemplo en un ciclo se declara la variable. Si se hace con var esta puede usarse fuera del ciclo, si se hace con let esta se restringe √∫nicamente al ciclo

# const

Son variasbles que una vez que se encuentran definidas, no puede modificarse. Son variable de solo lectura. Un ejemplo claro son las constantes matem√°ticas

![Untitled](img/Untitled%20205.png)

# Mutar arreglo declarado con const

Si declaramos un arreglo con const, este no podr√° definirse nuevamente. Sin embargo, podemos modificar sus elementos

![Untitled](img/Untitled%20206.png)

# Crear un objeto Inmutable

Si queremos definir un objeto que posteriormente no pueda ser editado, lo podemos volver inmujtable con Object.freeze de la siguiente manera

![Untitled](img/Untitled%20207.png)

# Funciones Flecha

Son un tipo de funciones m√°s compactas. Se utilizan cuando queremos definir funciones an√≥nimas, es decir sin un nombre espec√≠fico. En este caso vamos a definir una constante que se llama fecha y ser√° dada por una funci√≥n que retorne la fecha actual. As√≠ ser√≠a su equivalente en funci√≥n flecha

![Untitled](img/Untitled%20208.png)

![Untitled](img/Untitled%20209.png)

# Funci√≥n Flecha con Par√°metros

Veamos un s√≠mil entre una funci√≥n an√≥nima y una funci√≥n flecha definida con par√°metros

![Untitled](img/Untitled%20210.png)

![Untitled](img/Untitled%20211.png)

Hagamos un ejemplo. Desarrolllemos una funci√≥n que se llame concatenarArreglo y que concatene dos arreglos. Lo haremos con el tipo de funci√≥n an√≥nima y el tipo de funci√≥n flecha

![Untitled](img/Untitled%20212.png)

y as√≠ ser√≠a su equivalencia en funci√≥n flecha

![Untitled](img/Untitled%20213.png)

En el dado caso que la funci√≥n tenga m√°s de una una l√≠nea, deber√° estar envuelta entre llaves

![Untitled](img/Untitled%20214.png)

# Valores por Defecto para Par√°metros

Se pueden asignar por defecto valores a los par√°metros de una funci√≥n flecha.  De esta manera, si el usuario omite el par√°metro, se tomar√° ese valor por 

![Untitled](img/Untitled%20215.png)

# Operador rest

Este operador permite pasar cualquier n√∫mero de argumentos a una funci√≥n, y que estos argumentos se agrupen como un arreglo. Para ello, definimos una funci√≥n, y en donde definimos los par√°mentro, escribimos puntos suspensivos y un par√°metro. Esto nos permite definir que la funci√≥n no tenga un √∫nico par√°metro.

![Untitled](img/Untitled%20216.png)

![Untitled](img/Untitled%20217.png)

# Operador Spread

Hace lo contrario al operador rest. Toma un arreglo y lo descompone

Tenemos una contante definida como un arreglo y una frunci√≥n de suma.

Para llamar a la funci√≥n con par√°metros a los elemntos de arreglo, deber√≠amos llamar unbdividualmente cada uno de los elelentos del arreglo. Con la funci√≥n Spread (‚Ä¶numeros) se descompone cada uno de los elementos del arreglo y lo mete en la funci√≥n

![Untitled](img/Untitled%20218.png)

# Sintaxis de Desestructuraci√≥n

Nos permite asignar las propiedades de un objeto a variables

![Untitled](img/Untitled%20219.png)

![Untitled](img/Untitled%20220.png)

# Sintaxis de Desestructuraci√≥n: Objetos Anidados

![Untitled](img/Untitled%20221.png)

Otro ejemplo

![Untitled](img/Untitled%20222.png)

![Untitled](img/Untitled%20223.png)

![Untitled](img/Untitled%20224.png)

# Sintaxis de Desestructuraci√≥n: Arreglos

Nos permite asignar valores a variables, usando arreglos

Si tenemos un arreglo definido, no es necesario que todos sus elementos esten asignados a una variable, de esta manera

![Untitled](img/Untitled%20225.png)

![Untitled](img/Untitled%20226.png)

Tambien puede usarse para intercambiar el valor de dos variables

![Untitled](img/Untitled%20227.png)

# Sintaxis de Desestructuraci√≥n con el operador rest

Vamos a usar este operador para reasignar una arreglo en varias varibales. Vamos a declarar dos variables a y b, y las vamos a definir en un arreglo con 7 elementos. Solo a y b est√°n definidas. Usando rest, vamos a definir el resto

![Untitled](img/Untitled%20228.png)

Hgamos un ejercicios para eliminar los tres primeros elementos de un arreglo usando este principio

![Untitled](img/Untitled%20229.png)

![Untitled](img/Untitled%20230.png)

# Sintaxis de Desestructuraci√≥n: Pasar Objeto como Argumento

![Untitled](img/Untitled%20231.png)

![Untitled](img/Untitled%20232.png)

Otro ejemplo

![Untitled](img/Untitled%20233.png)

![Untitled](img/Untitled%20234.png)

# Plantillas Literales

Tambien llamadas Plantillas de Cadena. 

Caracter√≠sticas:

- Se usa el acento invertido (backtict) ` en lugar de comillas
- Pueden contener comillas simples y dobles
- Las l√≠neas se preservan como se escriben en el c√≥digo
- Para reemplazar una variable se escrobe ${variable}
- Dentro de ${} tambi√©n se pueden escribir expresiones

![Untitled](img/Untitled%20235.png)

otro ejemplo con arreglos

![Untitled](img/Untitled%20236.png)

Otro ejemplo con objetos

![Untitled](img/Untitled%20237.png)

![Untitled](img/Untitled%20238.png)

![Untitled](img/Untitled%20239.png)

# Crear Objetos de Forma Consisa

Veamos una manera de crear objetos de manera consisa

![Untitled](img/Untitled%20240.png)

y as√≠ lo hacemos de forma mas resumida

![Untitled](img/Untitled%20241.png)

# M√©todos

Dentro de un objeto, se pueden definir funciones. As√≠

el termino es el equivalente al objeto donde se esta trabajando

![Untitled](img/Untitled%20242.png)

Para abreviar, podemos quitar la palabra function y los :

![Untitled](img/Untitled%20243.png)

# Definir una Clase

Es un plano general que podemos escribir una sola vez y podemos reutilizarlo para crear tantos objetos como necesitemos. Hay una convenci√≥n para crear clases y es que la primera letra de la clase debe ser may√∫cula, a diferencia de las variables

![Untitled](img/Untitled%20244.png)

Hagamos un ejemplo diferente

![Untitled](img/Untitled%20245.png)

![Untitled](img/Untitled%20246.png)

# Getters y Setters

Son funciones de un objeto que permiten proteger la data de este

- Getter: Es una funci√≥n espec√≠fica que nos permiten obtener un valor de una propiedade de una propiedad privada
- Setter: Es una funci√≥n espec√≠fica que nos permite actualizar un valor de una propiedad

Para este ejemplo vamos a crear una clase que se llame Libro, all√≠ vamos a llamar la funci√≥n constructor que nos va a crear una propiedad autor con ese mismo nombre. Por convenci√≥n, podemos poner _autor para que se sepa que esta propiedad no debe modificarse (propiedad privada).

![Untitled](img/Untitled%20247.png)

![Untitled](img/Untitled%20248.png)

Si no se define el getter, no se va a poder acceder a la propiedad ya que esta es propiedad privada al colocarle _ antes del nombre